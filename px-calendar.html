<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-calendar-cell.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-range-behavior"/>
<link rel="import" href="../px-datetime-common/px-datetime-behavior"/>

<script src="../moment/moment.js"></script>

<!--
Element that renders a calendar for the given year and month, and highlights/selects the dates within the range given by the first/second range date.

The first range date may be before, after, or equal to the second range date, depending on the order of the user's clicks.

##### Usage

    <px-calendar display-month-year="{{...}}"
                 first-range-date="{{...}}"
                 second-range-date="{{...}}">
    </px-calendar>

-->
<dom-module id="px-calendar">
  <link rel="import" type="css" href="css/px-calendar.css"/>
  <template>
    <div class="table table--no-cells text--center" id="calendar">
      <!-- Caption: month+year and previous/next arrows  -->
      <div class="caption">
        <button on-tap="_onPrevious" class="btn btn--bare u--mr- btn-arrow caption_btn">
          <i class="fa fa-angle-left"></i>
        </button>
        <span on-tap="_onNextDisplayMode" class="caption_text">{{_getCurrentTitle(_currentDisplayMode, _momentBaseDate)}}</span>
        <button id=btnNextMonth on-tap="_onNext" class="btn btn--bare u--ml- btn-arrow caption_btn">
          <i class="fa fa-angle-right"></i>
        </button>
      </div>
      <!-- Actual Calendar -->

        <template is="dom-if" if="{{_isDayMode(_currentDisplayMode)}}">
          <div class="tr">
            <!-- Sunday -> Saturday -->
            <template is="dom-repeat" items="{{daysOfTheWeek}}" as="dayOfTheWeek">
              <span class="th caps u-pt0">{{dayOfTheWeek}}</span>
            </template>
          </div>
        </template>
        <template is="dom-repeat" items="{{_valuesDisplayed}}" as="week">
          <!-- 1 week per row -->
          <div class="tr">
            <template is="dom-repeat" items="{{week}}" as="date">
                <div class="td">
                  <px-calendar-cell display-date="{{date}}"
                                    first-range-date="{{firstRangeDate}}"
                                    second-range-date="{{secondRangeDate}}"
                                    allow-future-dates="{{allowFutureDates}}"
                                    is-utc="{{isUtc}}"
                                    display-mode="{{_currentDisplayMode}}">
                  </px-calendar-cell>
                </div>
            </template>
          </div>
        </template>

    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-calendar',
    behaviors: [pxDatetimeBehavior,
    pxDatetimeRangeBehavior],

    properties: {

      /**
       * Moment object used as the base for the calendar (to decide which month to display)
       */
      _momentBaseDate: {
        type: Object,
        notify: true,
        observer: '_renderCurrent',
        value: function() {
          return moment();
        }
      },
      /**
       *  What the calendar should display:
       *  'day': calendar displays all days of a month
       *  'month': calendar displays all months in a year
       *  'year': calendar displays a 10 years range
       *
       *  @default 'day'
       */
      displayMode: {
        type: String,
        value: 'day',
        observer: '_displayModeChanged'
      },
      /**
       *  What the calendar should display:
       *  'day': calendar displays all days of a month
       *  'month': calendar displays all months in a year
       *  'year': calendar displays a 10 years range
       *
       *  Can internally change when the user clicks the title and changes the mode
       *
       * @default day
       */
      _currentDisplayMode: {
        type: String,
        observer: '_renderCurrent',
        value: 'day'
      },
      /**
       * (optional)
       *
       * By default, the calendar will allow the user to select a range by clicking on 2
       * different date. If set this will only allow the user select a single date
       * each time he clicks
       *
       * @default false
       */
      preventRangeSelection: {
        type: Boolean,
        value: false
      },
      /**
       *  The values currently displayed in the calendar cells, days, months or years
       *
       * @default []
       */
      _valuesDisplayed: {
        type: Array,
        value: function() { return [];}
      },
      observers: ['_renderCurrent(_currentDisplayMode, _momentBaseDate)']
    },

    ready: function() {
      this.daysOfTheWeek = this._getDaysOfTheWeek();

      var handler = this._cellClicked.bind(this);
      this.$.calendar.addEventListener('px-date-selected', handler);
    },

    _cellClicked: function(e) {
      var momentDate = e.detail;

      if(this._currentDisplayMode === 'year') {
        if(this.displayMode === 'year') {
          //we want to select this year.
          this._selectYear();
        }
        else {
          //go to 'month' mode
          this.set('_momentBaseDate', momentDate);
          this.set('_currentDisplayMode', 'month');
        }
      }else if(this._currentDisplayMode === 'month') {
        if(this.displayMode === 'month') {
          //we want to select this month.
          this._selectMonth();
        }
        else {
          //go to 'day' mode
          this.set('_momentBaseDate', momentDate);
          this.set('_currentDisplayMode', 'day');
        }
      }else {
        this._selectDate(momentDate);
      }
    },

    _displayModeChanged: function() {
      this.set('_currentDisplayMode', this.displayMode);
    },

    _isDayMode: function(_currentDisplayMode) {
      return _currentDisplayMode === 'day';
    },

    /**
     *
     * Change the display mode after the user clicked the title
     */
    _onNextDisplayMode: function() {
      if(this._currentDisplayMode === 'day') {
        this.set('_currentDisplayMode', 'month');
      }else if(this._currentDisplayMode === 'month') {
        this.set('_currentDisplayMode', 'year');
      }
      //else year already, do nothing
    },

    _getCurrentTitle: function(_currentDisplayMode, _momentBaseDate) {
      if(_currentDisplayMode === 'day') {
        return _momentBaseDate.format('MMMM') + ' ' + _momentBaseDate.format('YYYY');
      }else if(_currentDisplayMode === 'month') {
        return _momentBaseDate.format('YYYY');
      }else {
        return _momentBaseDate.format('YYYY') + ' - ' + _momentBaseDate.clone().add(10, 'years').format('YYYY');
      }
    },

    _getDaysOfTheWeek: function() {
      var day = moment().startOf('week');
      var daysOfWeek = [];
      for (var i = 0; i < 7; i++) {
        daysOfWeek.push(day.format('dd'));
        day.add(1, 'days');
      }
      return daysOfWeek;
    },

    _renderCurrent: function(_currentDisplayMode, _momentBaseDate) {

      var newValues;
      if(this._currentDisplayMode === 'day') {
        newValues = this._constructMonth();
      }else if(this._currentDisplayMode === 'month') {
        newValues = this._constructYear();
      }else {
        newValues = this._constructYearRange();
      }
      this.set('_valuesDisplayed', newValues);

    },

    _selectDate: function(newSelectedDate) {

      if (!this.preventRangeSelection && this.firstRangeDate && !this.secondRangeDate) {
        // treat the click as the second date - the range is selected!
        this.set('secondRangeDate', newSelectedDate);
        this.fire('range-selected');
      }
      else {
        this.set('secondRangeDate', null);
        this.set('firstRangeDate', newSelectedDate);
      }
    },

    _constructYear: function() {
      //3 rows of 4 months
      var current = this._momentBaseDate.clone().month(0),
          months = [];

      for(var i=0; i<3; i++) {
        months[i] = [];
        for(var j=0; j<4; j++) {
          months[i].push(current);
          current = current.clone().add(1, 'months');
        }
      }

      return months;
    },

    _constructYearRange: function() {
      //2 rows of 5 years
      var current = this._momentBaseDate.clone(),
          years = [];

      for(var i=0; i<2; i++) {
        years[i] = [];
        for(var j=0; j<5; j++) {
          years[i].push(current);
          current = current.clone().add(1, 'years');
        }
      }

      return years;
    },

    _constructMonth: function() {

      var numberOfDaysInMonth = this._momentBaseDate.daysInMonth(),
          dayBeginningOfMonth = this._momentBaseDate.startOf('month').day(),
          numberOfWeeks = 6, // will always have 6 weeks to make calendar not change height
          daysBeforeMonthStartsCount = 0,
          date = 1,
          month = [];

      for (var weekCount = 0; weekCount < numberOfWeeks; weekCount++) {

        var week = [];

        while (daysBeforeMonthStartsCount < dayBeginningOfMonth) {
          week.push(moment(null)); // push empty cells on before the 1st of the month
          daysBeforeMonthStartsCount++;
        }

        while (week.length < 7) {
          if (date <= numberOfDaysInMonth) {
            week.push(this._momentBaseDate.clone().date(date));
            date++;
          }
          else {
            week.push(moment(null)); // push empty cells on after the last day of the month (to fill the week, extra weeks)
          }
        }
        month.push(week);
      }
      return month;
    },
    /**
     * Called when clicking the 'next' arrow
     */
    _onNext: function() {
      //create a new moment object so Polymer knows the property has changed
      var newMoment;
      if(this._currentDisplayMode === 'day') {
        newMoment = moment(this._momentBaseDate.add(1, 'months'));
      }else if(this._currentDisplayMode === 'month') {
        newMoment = moment(this._momentBaseDate.add(1, 'years'));
      }
      else {
        newMoment = moment(this._momentBaseDate.add(10, 'years'));
      }

      this.set('_momentBaseDate', newMoment);
    },
    /**
     * Called when clicking the 'previous' arrow
     */
    _onPrevious: function() {
      //create a new moment object so Polymer knows the property has changed
      var newMoment;
      if(this._currentDisplayMode === 'day') {
        newMoment = moment(this._momentBaseDate.subtract(1, 'months'));
      }else if(this._currentDisplayMode === 'month') {
        newMoment = moment(this._momentBaseDate.subtract(1, 'years'));
      }
      else {
        newMoment = moment(this._momentBaseDate.subtract(10, 'years'));
      }

      this.set('_momentBaseDate', newMoment);
    }

  });
</script>
